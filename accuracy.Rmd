---
title: "Transcranial direct current stimulation of the right frontal eye field in a prosaccade task"
author: Leon Reteig
subtitle: Saccade accuracy
output:
  html_notebook:
    toc: true
    toc_float: true
---

```{r include=FALSE}
library("knitr") # R markdown output (html, pdf, etc.)
knitr::opts_chunk$set(message = FALSE, warning = FALSE) # Don't show warnings and messages in HTML output
```

R notebook for inspection of data and analyses of saccade end point deviation and variability in the `sacc-tDCS` dataset. Previous processing:

* Raw data were parsed into events (saccades, fixations, etc.) by the EyeLink data were collected on.
* Events were extracted and saccade measures were computed with a MATLAB script.

```{r Load some libraries}
# Load some libraries
library(tidyverse) # importing, transforming, and visualizing data frames
library(ez) # ANOVAs with sphericity tests
library(BayesFactor) # Bayesian statistics

source("src/lib/InclusionBF.R")
```

# Load eye data

The .csv file with the eye tracking data was created in MATLAB.

```{r Load the data frame}
# Load the data frame
dataFile <- file.path("data", "sacc-tDCS_data.csv")
groupData <- read_csv(dataFile, col_names = TRUE, na = "NaN", progress = FALSE, col_types = cols(
  stimulation = col_factor(c("anodal","cathodal")),
  leg = col_factor(c("pre","tDCS","post")),
  type = col_factor(c("lateral","center")),
  direction = col_factor(c("left","right")) 
))
```

```{r Show data frame}
kable(head(groupData))
```

* __subject__: subject ID
* __stimulation__: Whether data are from the `anodal` or `cathodal` session
* __leg__: Whether data are before (`pre`), during (`tDCS`), or after (`post`) tDCS
* __block__: After each block participant had a brief break and tracker was recalibrated
* __trial__: trial number within a block
* __type__:
    * `lateral` - fixation in center of display, saccade made towards the periphery
    * `center` - fixation in periphery, saccade made back towards the center of the display
* __direction__: `left` for saccades towards the left of current fixation position; `right` for saccades to the right
* __deviation.start__ : distance (in visual angle) from saccade start point to fixation
* __deviation.end.x__: distance (in visual angle) from x-coordinate of saccade end point to x-coordinate of target location
* __deviation.end.y__: same for y-coordinate
* __amplitude__: distance (in visual angle) between saccade start and end point
* __latency__: time (in ms) from target onset to start of saccade
* __drift.x__: distance (in visual angle) between x-coordinate of average fixation position during the break to x-coordinate of fixation stimulus. This stimulus was displayed at each break in the task, so this data can be used as an estimate of offsets to do drift correction.
* __drift.y__: same for y-coordinate

# Preprocess data

## Outlier trials

```{r Outlier criteria}
tooFast <- 50
tooSlow <- 400
badFix <- 1.8
badSacc <- 8
subs2exclude <- "S28" # < 30 trials for certain conditions if we filter out outlier trials
```

Criteria for outliers:

* Discard fast saccades, with a latency of `r tooFast` ms or less
* Discard slow saccades, saccades with a latency of `r tooSlow` ms or more
* Discard inaccurate fixations, with saccade starting point more than `r badFix` degrees or more away from fixation
* Discard faulty saccades, with x-coordinate of saccade end point `r badSacc` degree or more away from the target

In [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045), this was:

* Fast saccades: 50 ms
* Slow saccades: 400 ms
* Bad fixations: 1.8 degrees
* Faulty saccades: opposite hemifield of target (here, that would be 8 degrees as targets were that eccentric)

```{r Remove outlier trials and subjects}
# Remove outliers and subjects
groupData <- filter(groupData,
                    # outliers
                    latency >= tooFast,
                    latency <= tooSlow,
                    deviation.start <= badFix,
                    deviation.end.x <= badSacc,
                    # subjects
                    !(subject %in% subs2exclude),
                    # missing values
                    complete.cases(groupData)
)
```

## Cut into 15-minute sections

Cut the post-block into two so we have four 15-minute intervals: one before, one during, and two after stimulation.

```{r 15-minute invervals}
# Split the "post" leg into two
groupData <- mutate(groupData,
                    leg = as.character(leg), # cannot edit leg if it's still a factor
                    leg = replace(leg, leg == "post" & block <= 3, "post.1"),
                    leg = replace(leg, block > 3, "post.2"),
                    leg = factor(leg, levels = c("pre", "tDCS", "post.1", "post.2")) # refactor and order levels
                    )
```

## Drift correction

Calibration isn't perfect, so there are always small offsets between the measurements and what people are actually looking at. Further, these measurement errors can increase with time away from calibration, which is known as drift.

After every 20 trials (40 saccades) there was a break in the task, in which we asked subjects to fixate the center of the screen before continueing. The offsets recorded here are thus a good estimate of drift, since here you can trust that subjects were actually looking at fixation spot on. 

To do drift correction, we simply subtract the offsets recorded in the break from the x- and y- coordinates of the eye data of interest.

```{r Drift correction}
# Add columns with drift-corrected values
groupData <- mutate(groupData,
                    deviation.end.x.corr = deviation.end.x - drift.x,
                    deviation.end.y.corr = deviation.end.y - drift.y)
```

If this does indeed work, then most trials should now have a smaller deviation.

```{r Check correction}
# Calculate percentage of trials with smaller deviations after drift correction
driftCorr <- groupData %>%
  summarize(
    trials = n(),
    smaller.drift.x = sum(abs(deviation.end.x.corr) < abs(deviation.end.x)) / trials * 100,
    smaller.drift.y = sum(abs(deviation.end.y.corr) < abs(deviation.end.y)) / trials * 100
  )
c(driftCorr$smaller.drift.x, driftCorr$smaller.drift.y)
```
Seems that it doesn't really work at all, because it only decreased the error on about 50 percent of trials!

Luckily, inspection of the data reveals that it doesn't seem to change much with or without drift correction.

# Saccade end point deviation

One estimate of the accuracy of saccades is the mean landing position with respect to the target location. [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045) also examined this, but found no effects of tDCS.

The simplest measure is the Euclidian distance (shortest straight line) between the saccade end point and the center of the target stimulus. We already have the deviations in the x- and y- directions in degrees of visual angle. Now we just need to calculate the length of the vector.

```{r Calculate end point deviation}
# Calculate end point deviation
devData <- mutate(groupData, deviation.end = sqrt(deviation.end.x^2 + deviation.end.y^2))
devDataCorr <- mutate(groupData, deviation.end = sqrt(deviation.end.x.corr^2 + deviation.end.y.corr^2))
```

## Prepare data frame for plotting & statistics

```{r Mean over trials - deviation}
# Mean over trials

# Without drift correction
devData <- devData %>%
  group_by(subject,stimulation,direction,type) %>% 
  summarise(baseline = mean(deviation.end[leg == "pre"]), # take average of 3 blocks, make new column
            tDCS = mean(deviation.end[leg == "tDCS"]),
            post.1 = mean(deviation.end[leg == "post.1"]),
            post.2 = mean(deviation.end[leg == "post.2"])) %>%
gather(leg, deviation.end, baseline, tDCS, post.1, post.2)  %>% # gather new columns to use as factor 
mutate(leg = factor(leg, levels = c("baseline", "tDCS", "post.1", "post.2"))) # reorder factor levels

# With drift correction
devDataCorr <- devDataCorr %>%
  group_by(subject,stimulation,direction,type) %>% 
  summarise(baseline = mean(deviation.end[leg == "pre"]),
            tDCS = mean(deviation.end[leg == "tDCS"]),
            post.1 = mean(deviation.end[leg == "post.1"]),
            post.2 = mean(deviation.end[leg == "post.2"])) %>%
gather(leg, deviation.end, baseline, tDCS, post.1, post.2)  %>%  
mutate(leg = factor(leg, levels = c("baseline", "tDCS", "post.1", "post.2")))
```

```{r Subtract baseline - deviation}
# Subtract baseline

# Without drift correction
devDataBase <- devData %>%
  group_by(subject,stimulation,direction,type) %>% 
  # subtract baseline block from others, make new column
  summarise(tDCS = deviation.end[leg == "tDCS"] - deviation.end[leg == "baseline"], 
            post.1 = deviation.end[leg == "post.1"] - deviation.end[leg == "baseline"],
            post.2 = deviation.end[leg == "post.2"] - deviation.end[leg == "baseline"]) %>%
gather(leg, deviation.end, tDCS, post.1, post.2) %>% # gather new columns to use as factor 
mutate(leg = factor(leg, levels = c("tDCS", "post.1", "post.2"))) # reorder factor levels

# With drift correction
devDataCorrBase <- devDataCorr %>%
 group_by(subject,stimulation,direction,type) %>% 
  summarise(tDCS = deviation.end[leg == "tDCS"] - deviation.end[leg == "baseline"], 
            post.1 = deviation.end[leg == "post.1"] - deviation.end[leg == "baseline"],
            post.2 = deviation.end[leg == "post.2"] - deviation.end[leg == "baseline"]) %>%
gather(leg, deviation.end, tDCS, post.1, post.2) %>% 
mutate(leg = factor(leg, levels = c("tDCS", "post.1", "post.2"))) 
```

## Plot

### With baseline block

```{r Line plot per leg - deviation}
kanaiPlotDev <- ggplot(devData, aes(leg, deviation.end, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
kanaiPlotDev
```

At first glance there don't seem to be many differences that are larger than the baseline differences and/or relate clearly to the polarity or timing of stimulation.

Let's look at the individual subject data:

```{r Line plot per subject - anodal}
kanaiPlotSubsAnodal <- ggplot(devData[devData$stimulation == "anodal", ], aes(leg, deviation.end)) +
  facet_grid(type ~ direction) +
  geom_line(aes(group = subject,color = subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") +
  ggtitle("Anodal session")
kanaiPlotSubsAnodal
```

```{r Line plot per subject - cathodal}
kanaiPlotSubsCathodal <- ggplot(devData[devData$stimulation == "cathodal", ], aes(leg, deviation.end)) +
  facet_grid(type ~ direction) +
  geom_line(aes(group = subject,color = subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") +
  ggtitle("Cathodal session")
kanaiPlotSubsCathodal
```

There are definitely some outliers, but mostly in terms of overall offset / baseline differences.

### Baseline subtracted

```{r Line plot from baseline - deviation}
kanaiPlotDevBase <- ggplot(devDataBase, aes(leg, deviation.end, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
kanaiPlotDevBase
```

This clearly shows that all the changes are quite tiny (less than 0.1 degree of visual angle). There appears to be a clear difference between anodal and cathodal for left-center saccades, but this pattern is already present in the baseline.

## Statistics

```{r Make subject a factor - deviation}
# Make "subject" a factor, so we can model the repeated measures
devDataBase$subject <- factor(devDataBase$subject)
```

### Frequentist

#### ANOVA matching Kanai et al. (2012) - lateral saccades

__Data__: 

* Outliers removed
* Collapsed into 15-minute intervals
* Subtract the baseline from each subsequent block
* Discard center, keep only lateral saccades

__Dependent measure__: saccade end point deviation (uncorrected)

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (tDCS, post.1, post.2)
* DIRECTION (left vs. right)

```{r Kanai ANOVA, results='asis'}

modelKanai <- ezANOVA(data = data.frame(filter(devDataBase, type == "lateral")),
                        dv = .(deviation.end), wid = .(subject), within = .(stimulation,leg,direction), type = 3)

kable(modelKanai$ANOVA)
```

### Bayesian

#### Linear mixed effects matching Kanai - lateral saccades

```{r Compute Bayes Factors cf. null model}
bfKanaiLateral = anovaBF(deviation.end~stimulation*leg*direction+subject, data = data.frame(filter(devDataBase, type == "lateral")), whichModels = "withmain", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiLateral = sort(bfKanaiLateral, decreasing = TRUE) # sort such that winning model is at the top
```

```{r results='asis'}
kable(select(extractBF(bfKanaiLateral), bf)) # show only the Bayes factors in a table
```

None of the models are actually better than the null model, so this matches the fact that there are no significant result in the frequentist analysis.

```{r Inclusion BF matched models}
# Inclusion Bayes Factors
lateral.matched.stim <- inclusionBF(bfKanaiLateral,"stimulation","matched")
lateral.matched.stim.dir <- inclusionBF(bfKanaiLateral,"stimulation:direction","matched")
lateral.matched.stim.dir.leg <- inclusionBF(bfKanaiLateral,"stimulation:direction:leg","matched")
```

* STIMULATION: $BF_{01} =$ `r round(1/lateral.matched.stim, digits = 1)`
* STIMULATION by DIRECTION: $BF_{01} =$ `r round(1/lateral.matched.stim.dir, digits = 1)`
* STIMULATION by DIRECTION by LEG: $BF_{01} =$ `r round(1/lateral.matched.stim.dir.leg, digits = 1)`

The inclusion Bayes factors are also quite inconclusive, except for the threeway interaction (because this model fits very poorly, still much more poorly then the one without it, even though this one also came in 2nd-to-last)

# Saccade end point variability

In the motor literature, people often look at the spread in movement endpoints, as it's often believed that this is what the motor system is trying to optimize (i.e. minimize). [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045) also examined this, but found no effects of tDCS.

They operationalized variability as the standard deviation of the x-coordinate of the saccade end point. It is arguably better to look at both the x- and y-coordinates, for which we would need a multivariate measure: the [Mahalanobis distance](http://stats.stackexchange.com/a/62147). Mahalanobis distance intuitively is a multivariate generalization of Z-scores.

Using the Mahalanobis distance gets around another problem with the standard deviation: for saccades, the spread in the x-direction is greater than the y-direction:

```{r Plot all end points}
ggplot(groupData, aes(deviation.end.x, deviation.end.y)) +
  xlim(-5,5) +
  ylim(-5,5) +
  geom_point(size = 0.1)
```

Because the shape of the distribution is ellipsoidal, distance along the x-axis cannot simply be equated to distance along the y-axis. Mahalanobis distance gets around this problem because it accounts for the covariance between the variables (for non-correlated variables with unit variance, Mahalanobis distance is equivalent to Euclidian distance).

## Calculate endpoint variability

### Horizontal standard deviation

```{r Horizontal standard deviation}
stdData <- groupData %>%
  group_by(subject,stimulation,leg,direction,type) %>% 
  summarise(std.deviation.x = sd(deviation.end.x))
```

This is a summary measure across trials, so we have one estimate per subject per condition:

```{r results='asis'}
kable(head(stdData))
```

### Mahalanobis distance

```{r Mahalanobis distance}
mahalData <- groupData %>%
  group_by(subject,stimulation,leg,direction,type) %>%
  nest(deviation.end.x,deviation.end.y) %>% # for each condition, make separate data frame for Mahalanobis distance
  mutate(mahalanobis.distance = purrr::map(data, ~mahalanobis(., colMeans(.), cov(.)))) %>% # apply function to each data frame
  unnest(mahalanobis.distance) # transform the results back into a column again
```

The Mahalanobis distance is estimated for each trial:

```{r results='asis'}
kable(head(mahalData))
```

## Prepare data frame for plotting & statistics

```{r Mean over trials - variability}

# Mean Mahalanobis distance over trials
mahalMean <- mahalData %>% 
  group_by(subject,stimulation,direction,type) %>% 
  summarise(baseline = mean(mahalanobis.distance[leg == "pre"]), # take average of 3 blocks, make new column
            tDCS = mean(mahalanobis.distance[leg == "tDCS"]),
            post.1 = mean(mahalanobis.distance[leg == "post.1"]),
            post.2 = mean(mahalanobis.distance[leg == "post.2"])) %>%
gather(leg, mahalanobis.distance, baseline, tDCS, post.1, post.2)  %>% # gather new columns to use as factor 
mutate(leg = factor(leg, levels = c("baseline", "tDCS", "post.1", "post.2"))) # reorder factor levels
```

```{r Subtract baseline - variability}
# Subtract baseline

# Horizontal standard deviation
stdDataBase <- stdData %>%
  group_by(subject,stimulation,direction,type) %>% 
  # subtract baseline block from others, make new column
  summarise(tDCS = std.deviation.x[leg == "tDCS"] - std.deviation.x[leg == "pre"], 
            post.1 = std.deviation.x[leg == "post.1"] - std.deviation.x[leg == "pre"],
            post.2 = std.deviation.x[leg == "post.2"] - std.deviation.x[leg == "pre"]) %>%
gather(leg, std.deviation.x, tDCS, post.1, post.2) %>% # gather new columns to use as factor 
mutate(leg = factor(leg, levels = c("tDCS", "post.1", "post.2"))) # reorder factor levels

# Mahalanobis distance
mahalMeanBase <- mahalMean %>%
 group_by(subject,stimulation,direction,type) %>% 
  summarise(tDCS = mahalanobis.distance[leg == "tDCS"] - mahalanobis.distance[leg == "baseline"], 
            post.1 = mahalanobis.distance[leg == "post.1"] - mahalanobis.distance[leg == "baseline"],
            post.2 = mahalanobis.distance[leg == "post.2"] - mahalanobis.distance[leg == "baseline"]) %>%
gather(leg, mahalanobis.distance, tDCS, post.1, post.2) %>% 
mutate(leg = factor(leg, levels = c("tDCS", "post.1", "post.2"))) 
```

## Plot

### With baseline block

```{r Line plot per leg - standard deviation}
kanaiPlotStd <- ggplot(stdData, aes(leg, std.deviation.x, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3) +
  ggtitle("Horizontal standard deviation")
kanaiPlotStd
```

```{r Line plot per leg - Mahalanobis}
kanaiPlotMahal <- ggplot(mahalMean, aes(leg, mahalanobis.distance, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3) +
  ggtitle("Average Mahalanobis distance")
kanaiPlotMahal
```

### Baseline subtracted

```{r Line plot from baseline - standard deviation}
kanaiPlotStdBase <- ggplot(stdDataBase, aes(leg, std.deviation.x, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3) +
  ggtitle("Horizontal standard deviation")
kanaiPlotStdBase
```

```{r Line plot from baseline - mahalanobis}
kanaiPlotMahalBase <- ggplot(mahalMeanBase, aes(leg, mahalanobis.distance, color = stimulation, shape = stimulation)) +     
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3) +
  ggtitle("Average Mahalanobis distance")
kanaiPlotMahalBase
```

## Statistics

```{r Make subject a factor - variability}
# Make "subject" a factor, so we can model the repeated measures
stdDataBase$subject <- factor(devDataBase$subject)
mahalMeanBase$subject <- factor(mahalMeanBase$subject)
```

### Frequentist

#### ANOVA matching Kanai et al. (2012) - lateral saccades

__Data__: 

* Outliers removed
* Collapsed into 15-minute intervals
* Subtract the baseline from each subsequent block
* Discard center, keep only lateral saccades

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (tDCS, post.1, post.2)
* DIRECTION (left vs. right)

__Dependent measure__: saccade end point horizontal standard deviation

```{r Kanai ANOVA standard deviation, results='asis'}

modelKanaiStd <- ezANOVA(data = data.frame(filter(stdDataBase, type == "lateral")),
                        dv = .(std.deviation.x), wid = .(subject), within = .(stimulation,leg,direction), type = 3)

kable(modelKanaiStd$ANOVA)
```

__Dependent measure__: saccade end point Mahalanobis distance

```{r Kanai ANOVA mahalanobis, results='asis'}

modelKanaiMahal <- ezANOVA(data = data.frame(filter(mahalMeanBase, type == "lateral")),
                        dv = .(mahalanobis.distance), wid = .(subject), within = .(stimulation,leg,direction), type = 3)

kable(modelKanaiMahal$ANOVA)
```

### Bayesian

#### Horizontal standard deviation, lateral saccades

```{r Compute Bayes Factors cf. null model - standard deviation}
bfKanaiStd = anovaBF(std.deviation.x~stimulation*leg*direction+subject, data = data.frame(filter(stdDataBase, type == "lateral")), whichModels = "withmain", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiStd = sort(bfKanaiStd, decreasing = TRUE) # sort such that winning model is at the top
```

```{r results='asis'}
kable(select(extractBF(bfKanaiStd), bf)) # show only the Bayes factors in a table
```

```{r Inclusion BF matched models - standard deviation}
# Inclusion Bayes Factors
std.lateral.matched.stim <- inclusionBF(bfKanaiStd,"stimulation","matched")
std.lateral.matched.stim.dir <- inclusionBF(bfKanaiStd,"stimulation:direction","matched")
std.lateral.matched.stim.dir.leg <- inclusionBF(bfKanaiStd,"stimulation:direction:leg","matched")
```

* STIMULATION: $BF_{01} =$ `r round(1/std.lateral.matched.stim, digits = 1)`
* STIMULATION by DIRECTION: $BF_{01} =$ `r round(1/std.lateral.matched.stim.dir, digits = 1)`
* STIMULATION by DIRECTION by LEG: $BF_{01} =$ `r round(1/std.lateral.matched.stim.dir.leg, digits = 1)`

#### Mahalanobis distance, lateral saccades

```{r Compute Bayes Factors cf. null model - mahalanobis distance}
bfKanaiMahal = anovaBF(mahalanobis.distance~stimulation*leg*direction+subject, data = data.frame(filter(mahalMeanBase, type == "lateral")), whichModels = "withmain", whichRandom = "subject", progress = FALSE, iterations = 100000)
bfKanaiMahal = sort(bfKanaiMahal, decreasing = TRUE)
```

```{r results='asis'}
kable(select(extractBF(bfKanaiMahal), bf))
```

```{r Inclusion BF matched models - mahalanobis}
# Inclusion Bayes Factors
mahal.lateral.matched.stim <- inclusionBF(bfKanaiMahal,"stimulation","matched")
mahal.lateral.matched.stim.dir <- inclusionBF(bfKanaiMahal,"stimulation:direction","matched")
mahal.lateral.matched.stim.dir.leg <- inclusionBF(bfKanaiMahal,"stimulation:direction:leg","matched")
```

* STIMULATION: $BF_{01} =$ `r round(1/mahal.lateral.matched.stim, digits = 1)`
* STIMULATION by DIRECTION: $BF_{01} =$ `r round(1/mahal.lateral.matched.stim.dir, digits = 1)`
* STIMULATION by DIRECTION by LEG: $BF_{01} =$ `r round(1/mahal.lateral.matched.stim.dir.leg, digits = 1)`