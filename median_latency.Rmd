---
title: "Transcranial direct current stimulation of the right frontal eye field in a prosaccade task"
author: Leon Reteig
subtitle: Inspection and median latency analysis
output:
  html_notebook:
    toc: true
    toc_float: true
---

```{r include=FALSE}
library("knitr") # R markdown output (html, pdf, etc.)
knitr::opts_chunk$set(message = FALSE, warning = FALSE) # Don't show warnings and messages in HTML output
```

R notebook for inspection of data and analyses of median saccade latency in the `sacc-tDCS` dataset. Previous processing:

* Raw data were parsed into events (saccades, fixations, etc.) by the EyeLink data were collected on.
* Events were extracted and saccade measures were computed with a MATLAB script.

```{r Load some libraries}
# Load some libraries
library("tidyverse")
library("ez") # ANOVA
library("BayesFactor") # Bayesian statistics

source("src/lib/InclusionBF.R")
```

# Load eye data

The .csv file with the eye tracking data was created in MATLAB.

```{r Load the data frame}
# Load the data frame
dataFile <- file.path("data", "sacc-tDCS_data.csv")
groupData <- read_csv(dataFile, col_names = TRUE, na = "NaN", progress = FALSE, col_types = cols(
  stimulation = col_factor(c("anodal","cathodal")),
  leg = col_factor(c("pre","tDCS","post")),
  type = col_factor(c("lateral","center")),
  direction = col_factor(c("left","right")) 
))
```

```{r Show data frame}
kable(head(groupData))
```

* __subject__: subject ID
* __stimulation__: Whether data are from the `anodal` or `cathodal` session
* __leg__: Whether data are before (`pre`), during (`tDCS`), or after (`post`) tDCS
* __block__: After each block participant had a brief break and tracker was recalibrated
* __trial__: trial number within a block
* __type__:
    * `lateral` - fixation in center of display, saccade made towards the periphery
    * `center` - fixation in periphery, saccade made back towards the center of the display
* __direction__: `left` for saccades towards the left of current fixation position; `right` for saccades to the right
* __deviation.start__ : distance (in visual angle) from saccade start point to fixation
* __deviation.end.x__: distance (in visual angle) from x-coordinate of saccade end point to x-coordinate of target location
* __deviation.end.y__: same for y-coordinate
* __amplitude__: distance (in visual angle) between saccade start and end point
* __latency__: time (in ms) from target onset to start of saccade
* __drift.x__: distance (in visual angle) between x-coordinate of average fixation position during the break to x-coordinate of fixation stimulus. This stimulus was displayed at each break in the task, so this data can be used as an estimate of offsets to do drift correction.
* __drift.y__: same for y-coordinate

# Inspect distributions

### Histograms for each subject 

```{r Histogram per subject, fig.height = 6}
histType <- ggplot(groupData, aes(latency, fill = type)) +
  facet_wrap(~subject, ncol = 5, scales = "free_y") +
  geom_histogram(binwidth = 5, color = "grey50", size = .2) +
  xlim(-50,300)
histType
```

__Stray observations:__

* Center saccades are much faster than lateral, though not to the same degree in all subjects
* Some have a fat short latency tail - too fast saccades that are virtually all towards the center: S10, S11, S22, S28
* Some appear bimodal (S28), but when split for type this is generally because center saccades are faster: S05, S06, S11
* Some look almost normally distributed (S10); others are very heavily right-skewed (S32)
* Some are super sharp (S08); others really broad (S01)

### Stimulation effects across subjects

```{r Density: stimulation across subjects}
dens <- ggplot(groupData, aes(latency, color = stimulation, linetype = leg)) +
  facet_grid(type ~ direction) +
  geom_density() +
  xlim(0, 250) +
  scale_color_brewer(palette = "Set1")
dens
```

### Session effects in each subject
```{r Density: anodal vs. cathodal baseline per subject, fig.height = 6}
denstDCS <- ggplot(groupData[groupData$leg == 'pre' & groupData$type == "lateral", ], aes(latency, color = stimulation)) +
  facet_wrap(~subject, ncol = 5, scales ="free_y") +
  geom_density() +
  xlim(0, 250) +
  scale_color_brewer(palette = "Set1") +
  ggtitle('Lateral saccades, baseline block')
denstDCS
```

For most subjects, the latency distributions in both sessions are reasonably similar. Note that this is the baseline block, so we also wouldn't expect any differences. In that light, it is a little worrisome that for some subjects the distributions differ markedly (S01, S02, S09, S12, S17, S21, S26, S29, S32).

# Outliers

## Outlier trials

```{r Outlier criteria}
tooFast <- 50
tooSlow <- 400
badFix <- 1.8
badSacc <- 8
```

Criteria for outliers:

* Discard fast saccades, with a latency of `r tooFast` ms or less
* Discard slow saccades, saccades with a latency of `r tooSlow` ms or more
* Discard inaccurate fixations, with saccade starting point more than `r badFix` degrees or more away from fixation
* Discard faulty saccades, with x-coordinate of saccade end point `r badSacc` degree or more away from the target

In [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045), this was:

* Fast saccades: 50 ms
* Slow saccades: 400 ms
* Bad fixations: 1.8 degrees
* Faulty saccades: opposite hemifield of target (here, that would be 8 degrees as targets were that eccentric)

```{r Mark trials as outliers}
# Mark outliers
groupData <- mutate(groupData, outlier = "non.outlier", # fill vector for all trials
                    outlier = ifelse(latency < tooFast, "fast", outlier), # mark too fast trials as "fast"
                    outlier = ifelse(latency > tooSlow, "slow", outlier), # mark too slow trials as "slow"
                    outlier = ifelse(deviation.start > badFix, "fixation", outlier), # mark bad fixations as "fixation"
                    outlier = ifelse(deviation.end.x > badSacc, "saccade", outlier), # mark inaccurate saccades as "saccade"
                    outlier = ifelse(is.na(latency), "none", outlier) # mark absence of saccade as "none"
                    )
```

### Plot latencies of outlier trials per subject

```{r Plot outlier trials per subject, fig.height = 6}
outlierPlotTrials <- ggplot(groupData[!(groupData$outlier %in% c("none", "non.outlier")), ], aes(interaction(stimulation,leg,block,trial), latency, color = outlier, shape = type)) +
  facet_wrap(~subject, ncol = 5, scales = "free_y") +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = tooFast, linetype = "dashed") +
  geom_hline(yintercept = tooSlow, linetype = "dashed") +
  xlab('Trial') +
  theme(axis.text.x = element_blank(), # remove x-axis (just trial count)
  axis.ticks.x = element_blank())
outlierPlotTrials
```

### Tally outlier types

```{r Tally outliers}
outlierTrialCount <- groupData %>%
  group_by(subject,outlier) %>%
  summarize(outlier_count = n()) %>%
  mutate(total = sum(outlier_count[outlier != "non.outlier"]))
```

```{r Table of outlier counts, results= 'asis'}
outlierTable <- outlierTrialCount %>%
  spread(outlier, outlier_count) %>%
  select(subject, non.outlier, total, none, fast, slow, fixation, saccade)
kable(outlierTable, caption = "Number of outlier trials per subject")
```

### Plot outlier counts per subject

```{r Plot outlier counts per subject}
outlierPlotSubjects <- ggplot(outlierTrialCount[!(outlierTrialCount$outlier %in% "non.outlier"), ], aes(subject, outlier_count, fill = outlier)) +
  geom_col() +
  coord_flip()
outlierPlotSubjects
```

__Stray observations:__

Differences between subjects:

* Some subjects have extremely clen data with barely any outliers (S02, S07, S18)
* Most subjects have quite a few outliers, especially S10, S16, S22, S25 and S28
* Only S01 has a sizable amount of slow saccades
* Only S16 has a sizable amount of saccades to the opposite hemifield
* Those subjects with many fast saccades also tend to have many bad fixations

General patterns:

* Occurence of outliers seems stable throughout the session: there aren't more/less in the beginning / end
* There are very few inaccurate saccades (makes sense, because task is easy and criterion is not strict)
* Most outliers are too fast saccades and bad fixations
* Slow saccades are lateral, fast saccades are to the center, because only the latter are predictable
* Bad fixations appear to be mostly center saccades (but this varies a lot). Perhaps the eyes already drift back towards the center, before executing the saccade?
* Or is the source of bad fixations simply poor quality of the eye tracker data? e.g. people are actually fixating, but due to drift it appears they are not.

### Tally number of non-outlier trials

Importantly, we should also see how many trials are left per condition after excluding outliers

```{r}
trialCount <- groupData %>%
  filter(outlier == "non.outlier") %>% # keep only non-outlier trials
  group_by(subject,stimulation,leg,direction,type) %>%
  summarise(trials = n()) %>% # count how many there are per subject per condition
  arrange(trials) # sort ascending
trialCount
```

__Candidates for rejection__

S28 should definitely be rejected, as certain conditions would have < 30 trials, some even as low as 2! This is mostly because there are many missing saccades (`none`), indicating poor data quality (or just not doing the task).

```{r List subjects to exclude}
subs2exclude <- "S28" 
```

* S22, mostly because of bad fixations, but also many missing saccades
* S16, because of missing saccades, bad fixations, and also many fast saccades
* S10, S24 S25 to a lesser extent

# Inspect medians

## Outlier subjects per condition

Next to rejecting outlier trials, we could also consider rejecting outlier subjects or certain conditions from the statistical tests. One way to detect outliers (that is itself robust to outliers, unlike the standard deviation) is the MAD-median rule (see [this blogpost](https://eurekastatistics.com/using-the-median-absolute-deviation-to-find-outliers/) and [this preprint](http://dx.doi.org/10.1101/151811)). The MAD is the _median absolute devian from the median_.

```{r Table of outliers per subject-condition combination}
outliersPerCondition <- groupData %>%
  filter(outlier == "non.outlier") %>% # drop all outlier trials
  group_by(subject,stimulation,leg,type,direction) %>%
  summarise(latency = median(latency)) %>% # compute median latency
  group_by(stimulation,leg,type,direction) %>%
  mutate(mad.median.rule = (abs(latency - median(latency)) / mad(latency))) %>% # deviation from the median, standardized by the MAD
  filter(mad.median.rule > 2.24) # MAD-median rule
outliersPerCondition
```

These are all the subject-condition combinations for which the MAD-median rule is violated. If we were to reject subjects with one more more violation, we would have to remove `r length(unique(outliersPerCondition$subject))` subjects.

There is some overlap with the analysis of outlier trials. For instance, there is reason to remove S28 in both analyses. But this is not always the case: S26 has very clean trial-data, but is still flagged as an outlier here because their median latencies are quite slow.

## Data per block

```{r Compute median in each condition}
# Compute median in each condition
latencyMedian <- groupData %>%
  filter(outlier == "non.outlier") %>% 
  group_by(subject,stimulation,leg,block,type,direction) %>%
  summarise(latency = median(latency))
```

### Full factorial plot

```{r Full factorial plot}
# Plot out all the data
fullPlot <- ggplot(latencyMedian, aes(interaction(block,leg), latency, color = stimulation, shape = stimulation)) +
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1)
fullPlot
```

For some reason cathodal is always faster than anodal. There is probably a few ms difference between them on average, also in the baseline block. This is clearly just random variation, but it could be a problem, since the effects we expect are not much bigger...

The above plot also shows a lot of variability, so it might be best to average over each 3 consecutive blocks so the data come in 15-minute intervals.

## 15-minute intervals (collapse 3 blocks)

```{r Compute median, collapsed across blocks}
# Compute median per leg
latencyMedianLeg <- groupData %>%
  filter(outlier == "non.outlier") %>%
  group_by(subject,stimulation,direction,type) %>% 
  summarise(baseline = median(latency[leg == "pre"]), # take average of 3 blocks, make new column
            tDCS = median(latency[leg == "tDCS"]),
            post.1 = median(latency[leg == "post" & block <= 3]),
            post.2 = median(latency[leg == "post" & block >= 4])) %>%
 gather(leg,latency,baseline,tDCS,post.1,post.2) %>% # gather new columns to use as factor
 mutate(leg = factor(leg, levels = c("baseline", "tDCS", "post.1", "post.2"))) # reorder factor levels
```

### Line plot per leg, individual subjects

Now make the same plot, but for the data collapsed over 3 blocks. Also draw the plot for each individual subject, so we can see which subjects drive the baseline difference, and in which direction the stimulation effect goes for each subject (if there is any).

```{r Line plot for each subject, fig.height= 6}
kanaiSubsPlot <- ggplot(latencyMedianLeg, aes(leg, latency, color = stimulation, shape = type)) +         
  facet_wrap(~subject, ncol = 5) +
  stat_summary(fun.y = mean, geom = "point", size = 2) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation))
kanaiSubsPlot
```

There are a couple of subjects that show large differences in the baseline already, especially S01. The stimulation effects seem to not be very apparent, but they could also drown out at this scale.

### Compute magnitude of baseline difference

Let's look at the size of the baseline difference per subject. 

```{r results = 'asis'}
baselineDiff <- latencyMedianLeg %>% 
  filter(leg == "baseline") %>% # keep only baseline data
  spread(stimulation, latency) %>% # make separate columns for anodal and cathodal
  mutate(latency.diff = anodal - cathodal) %>% # subtract the difference
  group_by(subject) %>% 
  summarise(latency.diff = mean(latency.diff))# keep the average difference per subject

kable(baselineDiff, caption = 'Difference between baseline saccade latencies in anodal and cathodal session')
```

There are a few subjects with substantial latency differences between sessions, so it's probably a good idea to subtract the baseline for the statistical analyses. The mean difference is `r round(mean(baselineDiff$latency.diff), digits = 1)` ms. So on average, the cathodal session is a little faster, so the counterbalancing is not perfect, but the difference is not very high.

## Preprocessing steps

### Exclude trials and subjects

```{r Exclude trials and subjects}
preproc <- groupData %>%
  filter(outlier == "non.outlier", !(subject %in% subs2exclude))
```

* Others?

### Cut into 15-minute intervals

Cut the post-block into two so we have four 15-minute intervals: one before, one during, and two after stimulation.

```{r Cut into 15-minute intervals}
preproc <- preproc %>%
  mutate(leg = as.character(leg), # cannot edit leg if it's still a factor
         leg = replace(leg, leg == "post" & block <= 3, "post.1"),
         leg = replace(leg, block > 3, "post.2"),
         leg = factor(leg, levels = c("pre", "tDCS", "post.1", "post.2")) # refactor and order levels
         )
```

### Other

* Check / control for session order effects, and that sessions are balanced?
* Do drift correction before rejecting trials

# Median reaction time plots and analyses

Here we simply extract median RTs for each condition and use a repeated measures ANOVA for statistical analysis, following [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045).

## With baseline block

```{r Compute median over blocks}
latencyMedianLeg <- preproc %>%
  group_by(subject,stimulation,direction,type) %>% 
  summarise(baseline = median(latency[leg == "pre"]), # take average of 3 blocks, make new column
            tDCS = median(latency[leg == "tDCS"]),
            post.1 = median(latency[leg == "post.1"]),
            post.2 = median(latency[leg == "post.2"])) %>%
  gather(leg,latency,baseline,tDCS,post.1,post.2) %>% # gather new columns to use as factor
  mutate(leg = factor(leg, levels = c("baseline", "tDCS", "post.1", "post.2"))) # reorder factor levels
```

### Line plot per leg over all subjects

Let's look at the group average plot for the first time.

```{r Line plot per leg}
kanaiPlot <- ggplot(latencyMedianLeg, aes(leg, latency, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
kanaiPlot
```

All differences between anodal & cathodal seem to be < 5 ms. Any differences that are there also 1) do not seem to differ much between the time blocks, or 2) be in the opposite direction for anodal and cathodal, with the possible exception of the first post-block in the center-right condition.

### Individual subjects

#### Anodal session

Let's look at the same plot for individual subjects, to see whether there are any consistent patterns or huge outliers there.

```{r Line plot per subject - anodal}
kanaiPlotSubsAnodal <- ggplot(latencyMedianLeg[latencyMedianLeg$stimulation == "anodal", ], aes(leg, latency)) +
  facet_grid(type ~ direction) +
  geom_line(aes(group=subject,color=subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") +
  ggtitle("Anodal session")
kanaiPlotSubsAnodal
```

There do appear to be some "outliers", but they are fairly well balanced (below or above the average), and >80% or so of subjects seem to cluster together. I don't see much evidence for systematic individual differences (e.g. slow subjects get faster; fast subjects get slower.)

#### Cathodal session

```{r Line plot per subject - cathodal}
kanaiPlotSubsCathodal <- ggplot(latencyMedianLeg[latencyMedianLeg$stimulation == "cathodal", ], aes(leg, latency)) +
  facet_grid(type ~ direction) +
  geom_line(aes(group=subject,color=subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") +
  ggtitle("Cathodal session")
kanaiPlotSubsCathodal
```

There seem to be less clear individual outliers, but the spread also seems a bit bigger (e.g. right-lateral)

## Subtract baseline

Baseline differences (while small here) are not informative and could obscure real changes from baseline within subjects. Also it's hard to see and compare the magnitude of the effects, also for instance because center saccades are much faster than lateral saccades. Therefore, subtract the baseline from each subsequent measurement.

```{r Subtract baseline}
latencyMedianBaseline <- latencyMedianLeg %>%
  group_by(subject,stimulation,direction,type) %>% # for each condition, subtract baseline scores and make new columns
  summarise(tDCS = latency[leg == "tDCS"] - latency[leg == "baseline"], 
           post.1 = latency[leg == "post.1"] - latency[leg == "baseline"],
           post.2 = latency[leg == "post.2"] - latency[leg == "baseline"]) %>%
  gather(leg, latency, tDCS, post.1, post.2)  %>% # gather new columns to use as factor 
  mutate(leg = factor(leg, levels = c("tDCS", "post.1", "post.2"))) # reorder factor levels
```

### Line plots per leg from baseline

```{r Line plot from baseline}
kanaiPlotBase <- ggplot(latencyMedianBaseline, aes(leg, latency, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3) +
  coord_cartesian(ylim = c(-15,15))
kanaiPlotBase
```

The biggest difference from baseline seems to be 4 ms max; the largest difference between the stimulation conditions is even tinier.

### Individual subjects

#### Anodal session

```{r Line plot from baseline per subject - anodal}
kanaiPlotBaseSubsAnodal <- ggplot(latencyMedianBaseline[latencyMedianBaseline$stimulation == "anodal", ], aes(leg, latency)) +
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group=subject,color=subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") + 
  ggtitle("Anodal difference from baseline")
kanaiPlotBaseSubsAnodal
```

#### Cathodal session

```{r Line plot from baseline per subject - cathodal}
kanaiPlotBaseSubsCathodal <- ggplot(latencyMedianBaseline[latencyMedianBaseline$stimulation == "cathodal", ], aes(leg, latency)) +
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group=subject,color=subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") + 
  ggtitle("Cathodal difference from baseline")
kanaiPlotBaseSubsCathodal
```

All of this is split pretty much 50-50, hence the average difference hovering around 0.

# Statistics

```{r Make subject a factor}
# Make "subject" a factor, so we can model the repeated measures
latencyMedianLeg$subject <- factor(latencyMedianLeg$subject)
latencyMedianBaseline$subject <- factor(latencyMedianBaseline$subject)
```

## Frequentist

### Omnibus anova - saccade latency

__Data__: Outlier trials removed, collapesed into 15-minute intervals. 

__Dependent measure__: saccadic latency

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (baseline, tDCS, post.1, post.2)
* TYPE (lateral vs. center)
* DIRECTION (left vs. right)

```{r Omnibus ANOVA, results='asis'}
modelOmni <- ezANOVA(data = data.frame(latencyMedianLeg), # Repeated over subjects; type 3 sums of squares (cf. SPSS)
                        dv = .(latency), wid = .(subject), within = .(stimulation, leg, type, direction), type = 3)
kable(modelOmni$ANOVA)
```

#### Main effect: type

```{r Omni Main effect of type}
latencyMedianLeg %>%
  group_by(subject,type) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(type, latency)) +
  stat_summary(fun.data = mean_cl_normal, size = 1) +
  geom_jitter(width = 0.25)
```

This simply reflects that center saccades are faster than lateral saccades, because the location of the target is known.

#### Interaction: leg by type

```{r Omni Interaction leg by type}
latencyMedianLeg %>%
  group_by(subject,leg,type) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = type)) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = type, linetype = type))
```

The effect of TYPE changes over time: lateral saccades become slower.

#### Interaction: leg by direction

```{r Omni Interaction leg by direction}
latencyMedianLeg %>%
  group_by(subject,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = direction)) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = direction, linetype = direction))
```

Some erratic changes over time that differ for leftwards vs. rightwards saccades. Still, mind the scale: the largest change is around 2 ms or so.

#### Interaction: stimulation by leg by direction

```{r Omni Interaction stimulation by leg by direction}
latencyMedianLeg %>%
  group_by(subject,stimulation,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = stimulation, color = stimulation)) +
  facet_wrap(~direction) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation))
```

This is actually the interaction of primary interest, but unlike in Kanai's study, there is a time course effect, and the data are collapsed over saccade-type (there were no "center" saccades in Kanai's study).

I would be skeptical of interpreting this effect, first of all because none of the effects exceed ~ 2 ms. Secondly, the patterns over time are generally quite erratic and do not match our hypotheses:

* In the anodal session, for right saccades, they seem to get slower in the post-blocks, which could be plausible. There is no reliable effect for left saccades (there is a change during tDCS, but it bounces both ways in the post block).
* In the cathodal session, there is a stable change for left sacades, and in the expected direction (slower RTs). But unlike the right-anodal effect, now it already occurs during the stimulation instead of in the post block. The pattern for right saccades is inconsistent.

#### Interaction: leg by type by direction

```{r Omni Interaction leg by type by direction}
latencyMedianLeg %>%
  group_by(subject,leg,type,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = type)) +
  facet_wrap(~direction) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = type, linetype = type))
```

The effect over time looks non-linear for left-center saccades. The "tDCS" block is the deviant here, but there is no interaction with stimulation.

Also, for right-lateral saccades, there is a big change that only emerges in the 2nd post-block.

### ANOVA matching Kanai et al. (2012) - lateral saccades

Differing from the previous omnibus analysis, [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045) analysed shifts from baseline and only had lateral saccades.

__Data__: 

* Outliers removed
* Collapsed into 15-minute intervals
* Subtract the baseline from each subsequent block
* Discard center, keep only lateral saccades

__Dependent measure__: saccadic latency

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (tDCS, post.1, post.2)
* DIRECTION (left vs. right)

```{r Kanai ANOVA, results='asis'}

modelKanai <- ezANOVA(data = data.frame(filter(latencyMedianBaseline, type == "lateral")),
                        dv = .(latency), wid = .(subject), within = .(stimulation,leg,direction), type = 3)

# OR, without the EZ package:
# modelKanai=aov(latency~stimulation*leg*direction + Error(subject/(stimulation*leg*direction)),data=latencyMedianBaselineLateral)
# summary(modelKanai)

kable(modelKanai$ANOVA)
```

#### Main effect of leg

```{r Kanai Main effect of leg}
latencyMedianBaseline %>%
  filter(type == "lateral") %>%
  group_by(subject,leg) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.data = mean_cl_normal, size = 1) +
  stat_summary(fun.y = mean, geom = "line", aes(group = 1)) +
  geom_jitter(width = 0.25)
```

Saccades become slower over time with respect to the baseline.

#### Leg by direction interaction

```{r Kania Interaction leg by direction}
latencyMedianBaseline %>%
  filter(type == "lateral") %>%
  group_by(subject,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = direction)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = direction, linetype = direction))
```

This main effect of leg is stronger for right saccades, but does not occur until the 2nd post-block.

#### Interaction: stimulation by leg by direction

This interaction is only marginally significant, but it is of primary interest, so let's still look at it in more detail.

```{r Kanai Interaction stimulation by leg by direction}
latencyMedianBaseline %>%
  filter(type == "lateral") %>%
  group_by(subject,stimulation,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = stimulation, color = stimulation)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  facet_wrap(~direction) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation))
```

It appears that this might not be a genuine stimulation effect, but that this "leg by direction" interaction just occurs slightly differently over the sessions. 

Subjects just seem to get slower over time, for all directions and stimulation conditions. But, this change is not linear from timepoint to timepoint. And, for right saccades in the cathodal condition, subjects dip below baseline the post-block (but just 0.5 ms).  

### ANOVA matching Kanai et al. (2012) - center saccades

Repeat the same ANOVA, but now for center saccades (which Kanai did not have).

```{r Kanai ANOVA center, results='asis'}

modelKanaiCenter <- ezANOVA(data = data.frame(filter(latencyMedianBaseline, type == "center")),
                        dv = .(latency), wid = .(subject), within = .(stimulation,leg,direction), type = 3)

# OR, without the EZ package:
# modelKanai=aov(latency~stimulation*leg*direction + Error(subject/(stimulation*leg*direction)),data=latencyMedianBaselineLateral)
# summary(modelKanai)

kable(modelKanaiCenter$ANOVA)
```

#### Main effect of direction

```{r Kanai-Center Main effect of direction}
latencyMedianBaseline %>%
  filter(type == "center") %>%
  group_by(subject,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(direction, latency)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "line", aes(group = 1), size = 2) +
  geom_line(aes(colour = subject, group = subject))
```

This seems to be a really tiny and variable effect, but apparently left saccades get somewhat slower and right saccades somewhat faster compared to baseline.

#### Leg by direction interaction

```{r Kanai-Center Interaction leg by direction}
latencyMedianBaseline %>%
  filter(type == "center") %>%
  group_by(subject,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = direction)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = direction, linetype = direction))
```

For both saccade directions, the direction effect gets smaller over time.

#### Stimulation by leg by direction interaction

This interaction is again marginally significant, but it is the effect that Kanai et al. (2012) found, so let's inspect.

```{r Kanai-Center Interaction stimulation by leg by direction}
latencyMedianBaseline %>%
  filter(type == "center") %>%
  group_by(subject,stimulation,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, colour = stimulation)) +
  facet_wrap(~direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation, linetype = stimulation))
```

For cathodal subjects get slower for left saccades and faster for right saccades, which is in the hypothesized direction. But again, the effect is quite small (4 ms max), and strangely: it is maximal during stimulation for the left saccades, but after stimulation for right saccades. For anodal the changes are so small I don't dare to interpret them.

## Bayesian

### Linear mixed effects matching Kanai - saccade latency

#### Test against the null model

```{r Compute Bayes Factors cf. null model}
bfKanaiLateral = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(filter(latencyMedianBaseline, type == "lateral")), whichModels = "withmain", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiLateral = sort(bfKanaiLateral, decreasing = TRUE) # sort such that winning model is at the top
```

First we compare all models to the most simple (null) model, which is the intercept only + random effect model: `latency ~ subject`. This does not test for effects of SUBJECT but models it as a nuisance factor (`whichRandom = "subject"`). In addition, to decrease the model space, we do not consider models that have an interaction without the corresponding main effects (`whichModels = "withmain"`).

```{r Extract Bayes Factors withMain, results='asis'}
kable(select(extractBF(bfKanaiLateral), bf)) # show only the Bayes factors in a table
```

The winning model is the one with just a main effect of LEG, with a Bayes factor of `r round(extractBF(bfKanaiLateral[1], onlybf = TRUE), digits = 1)`. And actually, this is the only model for which there is more evidence than the null model...

The conventional interpretation for Bayes Factors is the following:

* $BF_{10}$ < 0.1: strong evidence for H0
* 0.1 < $BF_{10}$ < .33: moderate evidence for H0
* 0.333 < $BF_{10}$ < 1: anecdotal evidence for H0

* $BF_{10}$ = 1: equivalent evidence for H0 and H1

* 1 $BF_{10}$ < 3: anecdotal evidence for H1
* 3 < $BF_{10}$ < 10: moderate evidence for H1
* $BF_{10}$ > 10: strong evidence H1 

So to switch between expressing the Bayes Factor as evidence for H1 ($BF_{10}$) or H0 ($BF_{01}$), you simply invert it (divide by 1).

We can compute the evidence for a particular effect by comparing this winning model with the best-fitting model that does _not_ contain the effect. We can compute the evidence for _absence_ of a particular effect by comparing the winning model with the best-fitting model that _does_ contain the effect.

The evidence for the effect of LEG can be quantified by comparing the Bayes factors of the first and the 4th model (because that is the first one that does _not_ contain LEG as a factor): `r round(extractBF(bfKanaiLateral[1] / bfKanaiLateral[4], onlybf = TRUE), digits = 1)`. This constitues strong evidence for the presence of a leg effect.

The evidence for the _absence_ of the STIMULATION by DIRECTION interaction can be quantified by comparing the Bayes factors of the first and the 10th model (because that is the first one that does not contain the interaction): `r round(extractBF(bfKanaiLateral[1] / bfKanaiLateral[10], onlybf = TRUE), digits = 1)`. This constitues (very) strong evidence for the absence of the interaction.

#### Test against the full model

Another option for quantifying evidence for a particular effect is to compare the full model to a model where that effect is omitted (`whichModels = top")`. The full model is `stimulation + direction + stimulation:direction + leg + stimulation:leg + direction:leg + stimulation:direction:leg + subject`.

```{r Compute Bayes Factors cf. full model}
bfKanaiLateralFull = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(filter(latencyMedianBaseline, type == "lateral")), whichModels = "top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiLateralFull
```

Removing the LEG effect from the model yields a lower Bayes Factor, so including this effect improved the model. This thus constitues (some) evidence for the alternative: 1 \ `r round(extractBF(bfKanaiLateralFull[5], onlybf = TRUE), digits = 3)` ` = ` `r round(extractBF(1/bfKanaiLateralFull[5], onlybf = TRUE), digits = 1)` 

On the contrary, removing the DIRECTION by STIMULATION effect actually improves the model, so there is moderate evidence for the absence of interaction effects.

#### Bayesian model averaging

The problem with the 1st option (comparing single models, for example to the winning model) is that for designs with many factors (and therefore models), it becomes risky and a bit subjective to base conclusions on just two models.

The problem with the 2nd option (comparing against the full model) is actually very apparent in this dataset: the full model is a terrible fit. It comes in last, and there is even a lot of evidence against it when compared to the null model!

One solution is to do Bayesian Model Averaging: compare multiple models and aggregate the Bayes Factors.

In the [JASP stats package](http://jasp-stats.org), this analysis is also called the "inclusion Bayes factor". Briefly, it compares all models that include the effect of interest vs. all models that do not. For examples and a conceptual explanation, see example 5 in: [Bayesian inference for psychology. Part II: Example applications with JASP](https://doi.org/10.3758/s13423-017-1323-7).

There's also a different way of calculating inclusion Bayes factors ([conceptualized by Sebastiaan Mathot](https://www.cogsci.nl/blog/interpreting-bayesian-repeated-measures-in-jasp)) that is currently being implemented in JASP. This is called the "inclusion Bayes factor across matched models", and is more selective in the set of models that's being compared than the standard inclusion BF. Briefly, the inclusion BF across matched models compares:

* all models that include the effect of interest, but NO interactions with the effect of interest, VERSUS
* the models that result from stripping the effect of interest from this set of models.

Let's compare the default inclusion Bayes Factors for the three effects of interest:

```{r Inclusion BF default}
# Default inclusion Bayes Factors
lateral.all.stim <- inclusionBF(bfKanaiLateral,"stimulation","all")
lateral.all.stim.dir <- inclusionBF(bfKanaiLateral,"stimulation:direction","all")
lateral.all.stim.dir.leg <- inclusionBF(bfKanaiLateral,"stimulation:direction:leg","all")
```

Doing the analysis this way, we also find (very) strong evidence against any of these effects, particularly for the interactions

* STIMULATION: $BF_{01} =$ `r round(1/lateral.all.stim, digits = 1)`
* STIMULATION by DIRECTION: $BF_{01} =$ `r round(1/lateral.all.stim.dir, digits = 1)`
* STIMULATION by DIRECTION by LEG: $BF_{01} =$ `r round(1/lateral.all.stim.dir.leg, digits = 0)`

My preferred approach is the inclusion Bayes factor across matched models. The evidence is qualitatively similar, but less strong, probably because we aren't including as many poorly fitting models in the model comparison:

```{r Inclusion BF matched models}

lateral.matched.stim <- inclusionBF(bfKanaiLateral,"stimulation","matched")
lateral.matched.stim.dir <- inclusionBF(bfKanaiLateral,"stimulation:direction","matched")
lateral.matched.stim.dir.leg <- inclusionBF(bfKanaiLateral,"stimulation:direction:leg","matched")
```

* STIMULATION: $BF_{01} =$ `r round(1/lateral.matched.stim, digits = 1)`
* STIMULATION by DIRECTION: $BF_{01} =$ `r round(1/lateral.matched.stim.dir, digits = 1)`
* STIMULATION by DIRECTION by LEG: $BF_{01} =$ `r round(1/lateral.matched.stim.dir.leg, digits = 1)`

### Linear mixed effects matching Kanai - center saccades

```{r Bayes Factor Kanai center}
bfKanaiCenter = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(filter(latencyMedianBaseline, type == "center")), whichModels="withmain", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiCenter <- sort(bfKanaiCenter, decreasing = TRUE) # sort such that winning model is at the top
```

```{r}
bfKanaiCenter = sort(bfKanaiCenter, decreasing = TRUE) # sort such that winning model is at the top
kable(select(extractBF(bfKanaiCenter), bf)) # show only the Bayes factors in a table
```

```{r Inclusion BF matched models - center saccades}

center.matched.stim <- inclusionBF(bfKanaiCenter,"stimulation","matched")
center.matched.stim.dir <- inclusionBF(bfKanaiCenter,"stimulation:direction","matched")
center.matched.stim.dir.leg <- inclusionBF(bfKanaiCenter,"stimulation:direction:leg","matched")
```

* STIMULATION $BF_{01} =$ `r round(1/center.matched.stim, digits = 1)`
* STIMULATION by DIRECTION $BF_{01} =$ `r round(1/center.matched.stim.dir, digits = 1)`
* STIMULATION by DIRECTION by LEG $BF_{01} =$ `r round(1/center.matched.stim.dir.leg, digits = 1)`
