---
title: "Transcranial direct current stimulation of the right frontal eye field in a prosaccade task"
author: Leon Reteig
output:
  html_notebook:
    toc: true
    toc_depth: 2
---

```{r include=FALSE}
# Don't show warnings and messages in HTML output
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

R notebook for statistical analysis of the `sacc-tDCS` dataset. Previous processing:

* Raw data were parsed into events (saccades, fixations, etc.) by the EyeLink data were collected on.
* Events were extracted and saccade measures were computed with a MATLAB script.

```{r Load some libraries}
# Load some libraries
library("dplyr") # wrangling data frame data
library("tidyr") # tidying data frames
library("ggplot2") # plotting
library("ez") # ANOVA
library("knitr") # R markdown output (html, pdf, etc.)
library("BayesFactor") # Bayesian statistics
library("retimes") # Ex-Gaussian reaction time distributions
```

# Questionnaires

## PANAS

### Load data

In each session of the experiment, participants completed the [Positive and Negative Affect Scale (PANAS)](http://booksite.elsevier.com/9780123745170/Chapter%203/Chapter_3_Worksheet_3.1.pdf) twice:

1. __Pre-measurement__: Before starting setup of the tDCS and eye tracker
2. __Post-measurement__: After the electrodes were removed following task completion

As most participants were native Dutch speakers, we also used a [Dutch language version](http://www.ekgp.ugent.be/pages/nl/vragenlijsten/PANAS.pdf) of the PANAS, as reported by [Engelen et al. (2006)](http://link.springer.com/article/10.1007/BF03087979).

```{r Load PANAS data}
# Load the data frame
dataFile <- file.path("data", "PANAS.csv")
panasData <- read.csv(dataFile, header = TRUE, sep = ";")

panasData$time <- factor(panasData$time, levels = c("pre","post")) # reorder levels chronologically instead of alphabetically
head(panasData) # show data frame
```

__Factors__:

* _subject_: subject ID (`S01`, `S02`, etc)
* _session_: Whether data are from the `first` or `second` session
* _stimulation_: Whether data are from the `anodal` or `cathodal` session
* _time_: Whether data are from the `pre` or `post` measurement

__DATA__:

The PANAS contains 20 items, split equally into positive and negative affect. Each item is rated on a Likert scale:

1. very slightly or not at all
2. a little
3. moderately
4. quite a bit
5. extremely

To obtain a positive affect score, we sum items: 1 (interested), 3 (excited), 5 (strong), 9 (enthusiastic), 10 (proud), 12 (alert), 14 (inspired), 16 (determined), 17 (attentive) and 19 (active).

To obtain a negative affect score, we sum items: 2 (distressed), 4 (upset), 6 (guilty), 7 (scared), 8 (hostile), 11 (irritable), 13 (ashamed), 15 (nervous), 18 (jittery) and 20 (afraid).

### Post-pre differences per item

```{r Subtract pre from post for each item}
panasPrePost <- panasData %>%
  group_by(subject,session,stimulation) %>% # for each subject, session, stimulation combination
  select(-time) %>% # don't do subtraction for this column
  summarise_each(funs(diff(.))) # subtract pre and post
```

Let's plot the post-pre differences for each item, split for stimulation session.

```{r Plot post-pre differences per item}
panasPrePost %>%
  gather(item, score, pos.1.interested:neg.20.afraid) %>% # gather all PANAS columns so it can be used as a factor
  ggplot(aes(item, score)) +
      stat_summary(fun.y = mean, geom = "point", position = position_dodge(width = 0.6), aes(color = stimulation)) +
      geom_hline(yintercept = 0, linetype = "dashed") +
      coord_cartesian(ylim = c(-1,1)) +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

Most scores become negative, meaning the `post` score was smaller than `pre`. So they generally feel "less" of everything. This seems particularly the case for positive affect, although participants do feel slightly more _proud_, _determined_, and _strong_.

They become particularly less _jittery_, _nervous_, _irritable_, and also less _attentive_, _active_, and _excited_.

The biggest differences between the sessions are in the positive items, except for _irritable_.

For some positive items, anodal stimulation results in a more positive score, while cathodal reesults in a more negative score: _alert_, _inspired_, _determined_, and _strong_.

### Composite positive/negative scores

```{r Sum the positive and negative items}
panasComposite <- panasData %>% 
  mutate(positive = rowSums(select(., contains("pos")))) %>% # sum all the positive scores together
  mutate(negative = rowSums(select(., contains("neg")))) %>% # sum all the negative scores together
  select(subject:time, positive, negative) %>% # drop the original PANAS columns
  gather(affect, score, positive, negative) # gather affect so it can be used as a factor
```

```{r Plot the composite scores}
ggplot(panasComposite, aes(time,score, color = stimulation)) +
facet_wrap(~affect) +
  geom_point(position = position_jitter(width = 0.5)) +
  stat_summary(fun.data = mean_cl_normal, position = position_dodge(width = 1))
```

The negative scores are much lower than the positive overall.

The pre to post differences are larger for positive scores, particularly for the cathodal session.

#### Statistics: positive scores

Repeated measures ANOVA with factors STIMULATION (anodal vs. cathodal) and TIME (pre vs. post)

```{r RM ANOVA for Positive scores}
panasCompositePositive <- filter(panasComposite, affect == "positive") # new data frame with only positive scores

modelPositive <- ezANOVA(data = data.frame(panasCompositePositive), # Repeated over subjects; type 3 sums of squares (cf. SPSS)
                        dv = .(score), wid = .(subject), within = .(stimulation, time), type = 3)
kable(modelPositive)
```

Subjects' mood becomes less positive after stimulation, particularly in the cathodal session

#### Statistics: negative scores

Repeated measures ANOVA with factors STIMULATION (anodal vs. cathodal) and TIME (pre vs. post)

```{r RM ANOVA for negative scores}
panasCompositeNegative <- filter(panasComposite, affect == "negative") # new data frame with only negative scores

modelNegative <- ezANOVA(data = data.frame(panasCompositeNegative), # Repeated over subjects; type 3 sums of squares (cf. SPSS)
                        dv = .(score), wid = .(subject), within = .(stimulation, time), type = 3)
kable(modelNegative)

```

Subjects' mood also become less negative after stimulation...

## tDCS sensations

After each session, subjects also completed a questionnaire probing tDCS sensations.

### Load data

```{r Load tDCS sensations data}
# Load the data frame
dataFile <- file.path("data", "tdcs_sensations.csv")
sensData <- read.csv(dataFile, header = TRUE, sep = ";", na.strings = "")

head(sensData) # show data frame
```

They were asked to which degree the following sensations were present during stimulation: _tingling_, _itching sensation_, _burning sensation_, _pain_, _headache_, _fatigue_, _dizziness_ and _nausea_. Each was rated on a scale from 0-4:

0. none
1. a little
2. moderate
3. strong
4. very strong

They also rated their confidence _that the sensations were caused by the stimulation_ on a scale from 0-4 (columns starting with `conf.`):

0. n/a (meaning they rated the sensation a 0 on the previous scale)
1. unlikely
2. possibly
3. likely
4. very likely

Finally, they filled in whether they felt one electrode more than the other (`felt.more`); (and if so, which and for which sensations).

__Factors__:

* _subject_: subject ID (`S01`, `S02`, etc)
* _session_: Whether data are from the `first` or `second` session
* _stimulation_: Whether data are from the `anodal` or `cathodal` session

### Plot sensation distribution

```{r tDCS sensation distributions}
sensData %>%
  select(everything(), -contains("conf"), -felt.more) %>% # drop the confidence columns
  gather(sensation, rating, itching:nausea) %>% # gather sensations so they can be used as a factor
  ggplot(aes(rating, fill = stimulation)) +
    facet_wrap(~sensation) +
    geom_histogram(position = "dodge", binwidth = 0.5) +
    xlim(0.5,4.5) +
    ggtitle("Sensations over 15 anodal sessions, 15 cathodal sessions")
```

_Nausea_ was never experienced; _dizziness_ and _pain_ are also rare, and mild.

_Burning_, _itching_ and _tingling_ are most frequently experienced and to a higher degree.

### Plot confidence distributions

```{r tDCS confidence distributions}
sensData %>%
  select(contains("conf"), subject, session, stimulation) %>% # drop the rating columns
  gather(sensation, rating, conf.itching:conf.nausea) %>%
  ggplot(aes(rating, fill = stimulation)) +
    facet_wrap(~sensation) +
    geom_histogram(position = "dodge", binwidth = 0.5) +
    xlim(0.5,4.5) +
    ggtitle("Confidence over 15 anodal sessions, 15 cathodal sessions")
```

For "local" sensations like _burning_, _tingling_ and _dizziness_, subjects have high confidence that these are due to tDCS. For more diffuse sensations, like _fatigue_ and _headache_, ratings are very low, so their occurence might just be due to performing the task for an extended period of time.

### Sensation difference between anode and cathode

```{r Sensations for anode and cathode}
sensData %>%
  select(felt.more, subject, session, stimulation) %>% # keep only the relevant column
  mutate(felt.more = factor(felt.more, levels = c("anode", "equal", "cathode"))) %>% # keep colors consistent
  ggplot(aes(stimulation, fill = felt.more)) +
    geom_bar() +
  scale_y_continuous(breaks = 1:15)
```

There's a pretty even split between which electrode people feel the most, so there don't appear to be worrisome biases. 

During anodal stimulation, the anode is felt more than the cathode; during cathodal stimulation the cathode is felt more than the anode. In other words, the electrode over the FEF is always felt more than the forehead electrode.

About a third of people did not indicate they felt one more than the other; this is slightly more in the cathodal session.

### Statistics

We will test for every sensation separately whether there was a difference between the anodal and cathodal sessions. Mann-Whitney-U tests are most appropriate here, as the data are ordinal (Likert) and do not look normally distributed.

#### Itching

```{r T-test for itching}
wilcox.test(sensData$itching[sensData$stimulation == "anodal"], sensData$itching[sensData$stimulation == "cathodal"])
```

#### Tingling

```{r T-test for tingling}
wilcox.test(sensData$tingling[sensData$stimulation == "anodal"], sensData$tingling[sensData$stimulation == "cathodal"])
```

#### Burning

```{r T-test for burning}
wilcox.test(sensData$burning[sensData$stimulation == "anodal"], sensData$burning[sensData$stimulation == "cathodal"])
```

#### Pain

```{r T-test for pain}
wilcox.test(sensData$pain[sensData$stimulation == "anodal"], sensData$pain[sensData$stimulation == "cathodal"])
```

#### Headache

```{r T-test for headache}
wilcox.test(sensData$headache[sensData$stimulation == "anodal"], sensData$headache[sensData$stimulation == "cathodal"])
```

#### Fatigue

```{r T-test for fatigue}
wilcox.test(sensData$fatigue[sensData$stimulation == "anodal"], sensData$fatigue[sensData$stimulation == "cathodal"])
```

#### Dizziness

```{r Test for dizziness}
wilcox.test(sensData$dizziness[sensData$stimulation == "anodal"], sensData$dizziness[sensData$stimulation == "cathodal"])
```

#### Nausea

```{r Test for nausea}
wilcox.test(sensData$nausea[sensData$stimulation == "anodal"], sensData$nausea[sensData$stimulation == "cathodal"])
```

Nausea was rated 0 by everyone for both anodal and cathodal.

# Load eye data

The .csv file with the eye tracking data was created in MATLAB.

```{r Load the data frame, echo=TRUE}
# Load the data frame
dataFile <- file.path("data", "sacc-tDCS_data.csv")
groupData <- read.csv(dataFile, header = TRUE, na.strings = "NaN")

```

```{r Format data frame}
# Format data frame
groupData <- select(groupData, -X) # drop final empty column named "X"
groupData$leg <- factor(groupData$leg, levels = c("pre", "tDCS", "post"))
```

```{r Show data frame}
kable(head(groupData))
```

* __subject__: subject IDj
* __stimulation__: Whether data are from the anodal or cathodal session
* __leg__: Whether data are before (`pre`), during (`tDCS`), or after (`post`) tDCS
* __block__: After each block participant had a brief break and tracker was recalibrated
* __trial__: trial number within a block
* __type__:
    * `lateral` - fixation in center of display, saccade made towards the periphery
    * `center` - fixation in periphery, saccade made back towards the center of the display
* __direction__: `left` for saccades towards the left of current fixation position; `right` for saccades to the right
* __deviation.start__ : distance (in visual angle) from saccade start point to fixation
* __deviation.end__: distance (in visual angle) from saccade end point to target location
* __amplitude__: distance (in visual angle) between saccade start and end point
* __latency__: time (in ms) from target onset to start of saccade

# Basic inspection

##  Reaction time distributions

### Histograms for each subject 

```{r Histogram per subject, fig.width=9.6}
histType <- ggplot(groupData, aes(latency, fill = type)) +
  facet_wrap(~subject, nrow = 3, scales ="free_y") +
  geom_histogram(binwidth = 5, color = "grey50", size = .2) +
  xlim(-50,300)
histType
```

__Stray observations:__

* Center saccades are much faster than lateral, though not to the same degree in all subjects
* Some have a fat short latency tail - too fast saccades that are virtually all towards the center: S05, S10, S11
* Some appear bimodal, but when split for type this is generally because center saccades are faster: S05, S06, S11
* Some are super sharp (S8); others really broad (S01)
* S01 has a very typical looking distribution, but slow

### Stimulation effects across subjects

```{r Density: stimulation across subjects, fig.width=9.6}
dens <- ggplot(groupData, aes(latency, color = stimulation, linetype = leg)) +
  facet_grid(type ~ direction) +
  geom_density() +
  xlim(0, 250) +
  scale_color_brewer(palette = "Set1")
dens
```

### Anodal vs. cathodal in each subject
```{r Density: anodal vs. cathodal per subject, fig.width=9.6}
denstDCS <- ggplot(groupData[groupData$leg == 'tDCS' & groupData$type == "lateral", ], aes(latency, color = stimulation)) +
  facet_wrap(~subject, nrow = 3, scales ="free_y") +
  geom_density() +
  xlim(0, 250) +
  scale_color_brewer(palette = "Set1") +
  ggtitle('Lateral saccades, tDCS block')
denstDCS
```

### Anodal session in each subject

```{r Density: anodal per leg and subject, fig.width=9.6}
densLegAnodal <- ggplot(groupData[groupData$stimulation == 'anodal' & groupData$type == "lateral", ], aes(latency, color = leg)) +
  facet_wrap(~subject, nrow = 3, scales ="free_y") +
  geom_density() +
  xlim(0, 250) +
  ggtitle('Lateral saccades, anodal')
densLegAnodal
```

### Cathodal session in each subject
```{r Density: cathodal per leg and subject, fig.width=9.6}
densLegCathodal <- ggplot(groupData[groupData$stimulation == 'cathodal' & groupData$type == "lateral", ], aes(latency, color = leg)) +
  facet_wrap(~subject, nrow = 3, scales ="free_y") +
  geom_density() +
  xlim(0, 250) +
  ggtitle('Lateral saccades, cathodal')
densLegCathodal
```

# Outliers

## Mark outliers

```{r Outlier criteria, include=FALSE}
tooFast= 50;
tooSlow = 400; 
badFix = 1.8;
badSacc = 8;
```

Criteria for outliers:

* Discard fast saccades, with a latency of `r tooFast` ms or less
* Discard slow saccades, saccades with a latency of `r tooSlow` ms or more
* Discard inaccurate fixations, with saccade starting point more than `r badFix` degrees or more away from fixation
* Discard faulty saccades, with saccade end point more than `r badSacc` degree or more away from the target

In [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045), this was:

* Fast saccades: 50 ms
* Slow saccades: 400 ms
* Bad fixations: 1.8 degrees
* Faulty saccades: opposite hemifield of target (here, that would be 8 degrees as targets were that eccentric)

```{r Mark trials as outliers}
# Mark outliers
groupData <- mutate(groupData, outlier = FALSE, # fill vector with FALSE for all trials
                    outlier = ifelse(latency < tooFast, "fast", outlier), # mark too fast trials as "fast"
                    outlier = ifelse(latency > tooSlow, "slow", outlier), # mark too slow trials as "slow"
                    outlier = ifelse(deviation.start > badFix, "fixation", outlier), # mark bad fixations as "fixation"
                    outlier = ifelse(deviation.end > badSacc, "saccade", outlier)) # mark inaccurate saccades as "saccade"

groupDataClean <- filter(groupData, outlier == FALSE) # make new data frame without outlier trials
```

## Plot outliers per subject

```{r Plot outliers per subject, fig.width=9.6}
outlierPlot <- ggplot(groupData[groupData$outlier != FALSE, ], aes(interaction(stimulation,leg,block,trial), latency, color = outlier, shape = type)) +
  facet_wrap(~subject, nrow = 4, scales = "free_y") +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = tooFast, linetype = "dashed") +
  geom_hline(yintercept = tooSlow, linetype = "dashed") +
  xlab('Trial') +
  theme(axis.text.x=element_blank(), # remove x-axis (just trial count)
  axis.ticks.x=element_blank())
outlierPlot
```

```{r Table of outlier counts, results='asis'}
outlierCount <- groupData %>%
  group_by(subject) %>%
  summarize(outlier_count = sum(outlier != FALSE, na.rm = TRUE))
kable(outlierCount, caption = "Number of outlier trials per subject")
```

__Stray observations:__

Differences between subjects:

* Some subjects have barely any outliers (S02, S07)
* Most subjects have quite a few outliers, especially S05,S06, S10 and S1. The mean is `r round(mean(outlierCount$outlier_count), digits = 0)` out of `r sum(groupData$subject == "S01")` trials in total
* Only S01 has a sizable amount of slow saccades
* S14 has a lot of negative latencies (and also long positive latencies)
* Those subjects with many fast saccades also tend to have many bad fixations (S06, S10, but see S08)

General patterns:

* Occurence of outliers seems stable throughout the session: there aren't more/less in the beginning / end
* There are very few inaccurate saccades (makes sense, because task is easy and criterion is not strict)
* Most outliers are too fast saccades and bad fixations
* Slow saccades are lateral, fast saccades are to the center, because only the latter are predictable
* Bad fixations appear to be mostly center saccades (but this varies a lot). Perhaps the eyes already drift back towards the center, before executing the saccade?
* Or is the source of bad fixations simply poor quality of the eye tracker data? e.g. people are actually fixating, but due to drift it appears they are not.

# Summary analysis

Here we simply extract median RTs for each condition and use a repeated measures ANOVA for statistical analysis, following [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045).

## Data per block

```{r Compute median in each condition}
# Compute median in each condition
latencyMedian <- groupDataClean %>%
  group_by(subject,stimulation,leg,block,type,direction) %>%
  summarise(latency = median(latency, na.rm = TRUE))
```

### Full factorial plot

```{r Full factorial plot, fig.width=9.6}
# Plot out all the data
fullPlot <- ggplot(latencyMedian, aes(interaction(block,leg), latency, color = stimulation, shape = stimulation)) +
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1)
fullPlot
```

There is a pretty sizable difference between the anodal & cathodal sessions in the baseline already: cathodal is always faster than anodal.

The above plot also shows a lot of variability, so it might be best to average over each 3 consecutive blocks so the data come in 15-minute intervals.

## 15-minute intervals (collapse 3 blocks)

```{r Compute median, collapsed across blocks}
# Compute median per leg
latencyMedianLeg <- groupDataClean %>%
  group_by(subject,stimulation,direction,type) %>% 
  summarise(baseline = median(latency[leg == "pre"], na.rm = TRUE), # take average of 3 blocks, make new column
            tDCS = median(latency[leg == "tDCS"], na.rm = TRUE),
            post.1 = median(latency[leg == "post" & block <= 3], na.rm = TRUE),
            post.2 = median(latency[leg == "post" & block >= 4], na.rm = TRUE)) %>%
 gather(leg,latency,baseline,tDCS,post.1,post.2) %>% # gather new columns to use as factor
 mutate(leg = factor(leg, levels = c("baseline", "tDCS", "post.1", "post.2"))) # reorder factor levels
```

### Line plot per leg, individual subjects

Now make the same plot, but for the data collapsed over 3 blocks. Also draw the plot for each individual subject, so we can see which subjects drive the baseline difference, and in which direction the stimulation effect goes for each subject (if there is any).

```{r Line plot for each subject, fig.width=9.6}
kanaiSubsPlot <- ggplot(latencyMedianLeg, aes(leg, latency, color = stimulation, shape = type)) +         
  facet_wrap(~subject, nrow = 5) +
  stat_summary(fun.y = mean, geom = "point", size = 2) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation))
kanaiSubsPlot
```

There are a couple of subjects that show large differences in the baseline already, especially S01.

### Compute magnitude of baseline difference

Let's look at the size of the baseline difference per subject. 

```{r results = 'asis'}
baselineDiff <- latencyMedianLeg %>% 
  filter(leg == "baseline") %>% # keep only baseline data
  spread(stimulation, latency) %>% # make separate columns for anodal and cathodal
  mutate(latency.diff = anodal - cathodal) %>% # subtract the difference
  group_by(subject) %>% 
  summarise(latency.diff = mean(latency.diff))# keep the average difference per subject

kable(baselineDiff, caption = 'Difference between baseline saccade latencies in anodal and cathodal session')
```

There are a few subjects with substantial latency differences between sessions; the three largest of which are all slower in the anodal session (positive values). The mean difference is `r round(mean(baselineDiff$latency.diff), digits = 1)` ms.

### Exclude S01

It seems reasonable to exclude subject 1 from further analysis, because of three things:

* S01 shows the largest baseline difference between the anodal and cathodal sessions.
* Overall, S01 is much slower than all other subjects, by several tens of milliseconds.
* The first session for S01 was aborted because S01 was not feeling well. It was repeated at a later date, so S01 came to the lab 3 times in total instead of two.

However, S01 also seems to show the largest effect of stimulation, for both anodal and cathodal stimulation. It is even in the expected direction: faster saccades than baseline in the anodal session, slower in cathodal.

```{r Exclude S01}
latencyMedianLegExcl <- filter(latencyMedianLeg, subject != "S01") # discard rows from S01
latencyMedianLegExcl$subject <- factor(latencyMedianLegExcl$subject) #remake factor as it now has one level less
```

### Line plot per leg over all subjects

Now that we've excluded subject(s) and collapsed data over blocks, let's look at the group average plot for the first time.

```{r Line plot per leg}
kanaiPlot <- ggplot(latencyMedianLegExcl, aes(leg, latency, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
kanaiPlot
```

Even without S01, there is still a small baseline difference of `r round(mean(baselineDiff$latency.diff[baselineDiff$subject != "S01"]), digits = 1)` ms. There also seems to be a tiny effect in the center-left saccade condition that's in the expected direction for both stimulation sessions, but it's about the size of the baseline difference.

## Subtract baseline

The baseline difference is not informative and could obscure real changes from baseline within subjects. Therefore, subtract the baseline from each subsequent measurement.

```{r Subtract baseline}
latencyMedianBaseline <- latencyMedianLegExcl %>%
  group_by(subject,stimulation,direction,type) %>% # for each condition, subtract baseline scores and make new columns
  summarise(tDCS = latency[leg == "tDCS"] - latency[leg == "baseline"], 
           post.1 = latency[leg == "post.1"] - latency[leg == "baseline"],
           post.2 = latency[leg == "post.2"] - latency[leg == "baseline"]) %>%
  gather(leg, latency, tDCS, post.1, post.2)  %>% # gather new columns to use as factor 
  mutate(leg = factor(leg, levels = c("tDCS", "post.1", "post.2"))) # reorder factor levels
```

### Line plots per leg from baseline

```{r Line plot from baseline}
kanaiPlotBase <- ggplot(latencyMedianBaseline, aes(leg, latency, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3) +
  coord_cartesian(ylim = c(-15,15))
kanaiPlotBase
```

All changes from baseline are really tiny: 5 ms or less.

### Individual subjects, anodal session

```{r Line plot per subject - anodal}
kanaiPlotBaseSubsAnodal <- ggplot(latencyMedianBaseline[latencyMedianBaseline$stimulation == "anodal", ], aes(leg, latency)) +
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group=subject,color=subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") +
  ggtitle("Anodal difference from baseline")
kanaiPlotBaseSubsAnodal
```

For the center saccades, most subjects follow the expected direction and are below the line. The left-lateral effect that is of primary interest is erratic though: only ~10 subjects are below the line, and none show an online-effect larger than 12 ms.

### Individual subjects, cathodal session

```{r Line plot per subject - cathodal}
kanaiPlotBaseSubsCathodal <- ggplot(latencyMedianBaseline[latencyMedianBaseline$stimulation == "cathodal", ], aes(leg, latency)) +
  facet_grid(type ~ direction) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group=subject,color=subject)) +
  stat_summary(fun.y = mean, aes(group = stimulation), geom = "line") +
  stat_summary(fun.y = mean, geom = "point") + 
  ggtitle("Cathodal difference from baseline")
kanaiPlotBaseSubsCathodal
```

All of this is split pretty much 50-50, hence the average difference hovering around 0.

# Reaction time distributions

## Split data in equal blocks

We want the same number of trials to go into each distribution, so we'll split the 30-minute long `post` leg into two. Then we have 4 15-minute long data segments: `pre`, `tDCS`, `post.1` and `post.2`.

```{r Create 4 legs}
# Group single-trial data in 4 legs instead of 3
groupDataBlocked <- groupData %>%
  mutate(leg = as.character(leg)) %>% #un-factor the leg column so we can change it
  mutate(leg=replace(leg, leg == "post", "post.1"), # split the "post" level into two
         leg=replace(leg, block > 3, "post.2")) %>%
  mutate(leg = factor(leg, levels = c("pre","tDCS","post.1","post.2"))) #re-factor
```

## Fit the model

Next we fit an ex-gaussian distribution using the `retimes` package. One model is fit for each combination of:

* SUBJECT (S01, S02, etc.)
* STIMULATION (anodal, cathodal)
* LEG (pre, tDCS, post.1, post.2)
* TYPE (center, lateral)
* DIRECTION (left, right)

The ex-gaussian distribution is the convolution of a normal and an exponential distribution. It can be characterized with 3 parameters:

* $\mu$ (_mu_): the mean of the normal distribution
* $\sigma$ (_sigma_): the variance of the normal distribution
* $\tau$ (_tau_): the rate parameter of the exponential distribution

We'll do minimal pre-processing: keep all subjects, only discard negative RTs

```{r Fit ex-gaussian}
groupDataFit <- groupDataBlocked %>%
  filter(latency > 0) %>% # throw out missing and negative RTs
  group_by(subject,stimulation,leg,type,direction) %>% # for every condition
  summarise(result = list(data.frame(t(attr(timefit(latency),"par"))))) %>% # [see below]
  ungroup() %>% # remove grouping information (otherwise unnest will not work)
  unnest() # unpack the list column, so each parameter gets its own column
  
# 1. fit the ex-gaussian to the latency data with the timefit() function
# 2. extract the fitted parameters from the resulting object with "attr()"
# 3. transpose ("t()") so every parameter is in a different column
# 4. convert to a data frame with one column per parameter
# 5. pack in a list so we have something of size 1 we can assign to the dataframe
# "result" is now a list-column, where each element is a dataframe with estimates of the 3 parameters

# Alternatively, create a function to fit the data, and then call it through dplyr::do
#myFunc <- function(x){
#  data.frame(t(attr(timefit(x),"par")))
#}
#groupDataFit <- groupDataBlocked %>%
#  group_by(subject,stimulation,leg,type,direction) %>% # for every condition
#  do((myFunc(.$latency)))
```

## Inspect fitted parameters

```{r Inspect fitted mu parameter, fig.width = 9.6}
ggplot(groupDataFit, aes(interaction(leg,stimulation), mu, color = subject)) +
  facet_grid(type~direction) + 
  stat_summary(fun.y = mean, fun.ymin = function(x) mean(x) - 2*sd(x), fun.ymax = function(x) mean(x) + 2*sd(x), aes(group = 1)) + # plot mean and 2*SD to watch for outliers; we need group = 1 because the x-axis is a combination of factors
  geom_jitter(width = 0.6) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

For center saccades some estimates of $\mu$ are simply too fast (e.g. S09); they reflect premature eye movements. The distribution is also not a good fit in these cases.

For center saccades, it looks reasonable. S01 is more than 2 SD away from the mean, but the fit is excellent.

```{r Inspect fitted sigma parameter, fig.width = 9.6}
ggplot(groupDataFit, aes(interaction(leg,stimulation), sigma, color = subject)) +
  facet_grid(type~direction) +
  stat_summary(fun.y = mean, fun.ymin = function(x) mean(x) - 2*sd(x), fun.ymax = function(x) mean(x) + 2*sd(x), aes(group = 1)) +
  geom_jitter(width = 0.6) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

Center saccades appear to have larger $\sigma$ than lateral. But if you inspect the distributions, the peak is actually much sharper, which should indicate lower variance. The problem is that the shape of many distributions does not conform well: many saccades are early and have little variance, but then there's also a bump in the right-tail which causes the sigma-parameter to increase.

Values for the lateral distribution seem reasonable. 2 estimates of $\sigma$ are too close to zero, others are too high, but the spread is not unreasonable. Inspecting these distributions also reveals presence of a "shoulder" right of the peak, which can either spread the distribution out or narrow it too much.

```{r Inspect fitted tau parameter, fig.width = 9.6}
ggplot(groupDataFit, aes(interaction(leg,stimulation), tau, color = subject)) +
  facet_grid(type~direction) +
  stat_summary(fun.y = mean, fun.ymin = function(x) mean(x) - 2*sd(x), fun.ymax = function(x) mean(x) + 2*sd(x), aes(group = 1)) +
  geom_jitter(width = 0.6) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

Particularly for center saccades, $\tau$ is many times estimated at 0. This means that the distribution is actually just a normal distribution. For center saccades that makes sense, as $\tau$ is responsible for the longer right tail that characterizes the ex-gaussian distribution. When saccades are all super fast, this tail is not present.

## Mu

### Plot

```{r mu plot}
muLinePlot <- ggplot(groupDataFit, aes(leg, mu, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
muLinePlot
```

### Statistics

#### Lateral

```{r}
muLateral <- groupDataFit %>%
  filter(type == "lateral") %>%
  select(-type)
```

```{r mu lateral anova, results = 'asis'}
modelMuLateral <- ezANOVA(data = data.frame(muLateral), dv = .(mu), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelMuLateral$ANOVA)
```

```{r mu lateral Bayes}
bfMuLateral = anovaBF(mu~stimulation*leg*direction+subject, data = data.frame(muLateral), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfMuLateral
```

#### Center

```{r}
muCenter <- groupDataFit %>%
  filter(type == "center") %>%
  select(-type)
```

```{r mu center anova, results = 'asis'}
modelMuCenter <- ezANOVA(data = data.frame(muCenter), dv = .(mu), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelMuCenter$ANOVA)
```

```{r mu center Bayes}
bfMuCenter = anovaBF(mu~stimulation*leg*direction+subject, data = data.frame(muCenter), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfMuCenter
```

## Sigma

### Plot

```{r sigma plot}
sigmaLinePlot <- ggplot(groupDataFit, aes(leg, sigma, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
sigmaLinePlot
```

### Statistics

#### Lateral

```{r}
sigmaLateral <- groupDataFit %>%
  filter(type == "lateral") %>%
  select(-type)
```

```{r sigma lateral anova, results = 'asis'}
modelSigmaLateral <- ezANOVA(data = data.frame(sigmaLateral), dv = .(sigma), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelSigmaLateral$ANOVA)
```

```{r sigma lateral Bayes}
bfSigmaLateral = anovaBF(sigma~stimulation*leg*direction+subject, data = data.frame(sigmaLateral), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfSigmaLateral
```

#### Center

```{r}
sigmaCenter <- groupDataFit %>%
  filter(type == "center") %>%
  select(-type)
```

```{r sigma center anova, results = 'asis'}
modelSigmaCenter <- ezANOVA(data = data.frame(sigmaCenter), dv = .(sigma), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelSigmaCenter$ANOVA)
```

```{r sigma center Bayes}
bfSigmaCenter = anovaBF(sigma~stimulation*leg*direction+subject, data = data.frame(sigmaCenter), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfSigmaCenter
```

## Tau

### Plot

```{r tau plot}
tauLinePlot <- ggplot(groupDataFit, aes(leg, tau, color = stimulation, shape = stimulation)) +         
  facet_grid(type ~ direction) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  stat_summary(fun.y = mean, geom = "line", aes(group = stimulation), size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.3)
tauLinePlot
```

### Statistics

#### Lateral

```{r}
tauLateral <- groupDataFit %>%
  filter(type == "lateral") %>%
  select(-type)
```

```{r tau lateral anova, results = 'asis'}
modelTauLateral <- ezANOVA(data = data.frame(tauLateral), dv = .(tau), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelTauLateral$ANOVA)
```

```{r tau lateral Bayes}
bfTauLateral = anovaBF(tau~stimulation*leg*direction+subject, data = data.frame(tauLateral), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfTauLateral
```

#### Center

```{r}
tauCenter <- groupDataFit %>%
  filter(type == "center") %>%
  select(-type)
```

```{r tau center anova, results = 'asis'}
modelTauCenter <- ezANOVA(data = data.frame(tauCenter), dv = .(tau), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelTauCenter$ANOVA)
```

```{r tau center Bayes}
bfTauCenter = anovaBF(tau~stimulation*leg*direction+subject, data = data.frame(tauCenter), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfTauCenter
```

# Statistics

## T-tests for baseline differences

First, test for baseline differences for each combination of DIRECTION (left, right) and TYPE (center, lateral).

```{r T-tests for baseline differences}

# keep only the baseline for left-lateral-saccades
latencyMedianPreLeftLateral <- latencyMedianLegExcl %>%
  filter(leg == "baseline", type == "lateral", direction == "left") %>%
  select(-leg,-type,-direction) %>%
  spread(stimulation, latency)

# keep only the baseline for right-lateral-saccades
latencyMedianPreRightLateral <- latencyMedianLegExcl %>%
  filter(leg == "baseline", type == "lateral", direction == "right") %>%
  select(-leg,-type,-direction) %>%
  spread(stimulation, latency)

# keep only the baseline for right-center-saccades
latencyMedianPreRightCenter <- latencyMedianLegExcl %>%
  filter(leg == "baseline", type == "center", direction == "right") %>%
  select(-leg,-type,-direction) %>%
  spread(stimulation, latency)

# keep only the baseline for left-center-saccades
latencyMedianPreLeftCenter <- latencyMedianLegExcl %>%
  filter(leg == "baseline", type == "center", direction == "left") %>%
  select(-leg,-type,-direction) %>%
  spread(stimulation, latency)

t.test(latencyMedianPreLeftLateral$anodal,latencyMedianPreLeftLateral$cathodal, paired = TRUE )
t.test(latencyMedianPreRightLateral$anodal,latencyMedianPreRightLateral$cathodal, paired = TRUE )
t.test(latencyMedianPreLeftCenter$anodal,latencyMedianPreLeftCenter$cathodal, paired = TRUE )
t.test(latencyMedianPreRightCenter$anodal,latencyMedianPreRightCenter$cathodal, paired = TRUE )
```

None of the baseline differences are significant, so there is reason to leave the baseline data in the rest of the analyses.

## Omnibus anova - saccade latency

__Data__: Outliers removed, collapesed into 15-minute intervals. 

__Dependent measure__: saccadic latency

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (baseline, tDCS, post.1, post.2)
* TYPE (lateral vs. center)
* DIRECTION (left vs. right)

```{r Omnibus ANOVA, results='asis'}
modelOmni <- ezANOVA(data = data.frame(latencyMedianLegExcl), # Repeated over subjects; type 3 sums of squares (cf. SPSS)
                        dv = .(latency), wid = .(subject), within = .(stimulation, leg, type, direction), type = 3)
kable(modelOmni$ANOVA)
```

### Main effect: type

```{r Main effect of type}
latencyMedianLegExcl %>%
  group_by(subject,type) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(type, latency)) +
  stat_summary(fun.data = mean_cl_normal, size = 1) +
  geom_jitter(width = 0.25)
```

This simply reflects that center saccades are faster than lateral saccades, because the location of the target is known.

### Interaction: leg by type

```{r Interaction leg by type}
latencyMedianLegExcl %>%
  group_by(subject,leg,type) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = type)) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = type, linetype = type))
```

The effect of TYPE becomes larger over time: center saccades get faster, lateral saccades become slower.

### Interaction: leg by type by direction

```{r Interaction leg by type by direction}
latencyMedianLegExcl %>%
  group_by(subject,leg,type,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = type)) +
  facet_wrap(~direction) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = type, linetype = type))
```

This interaction of LEG and TYPE appears to occur to a lesser extent for left saccades. The "tDCS" block is the deviant here, but there is no interaction with stimulation.

## ANOVA matching Kanai et al. (2012) - saccade latency

Differing from the previous omnibus analysis, [Kanai et al. (2012)](http://dx.doi.org/10.3389/fpsyt.2012.00045) analysed shifts from baseline and only had lateral saccades.

__Data__: 

* Outliers removed
* Collapsed into 15-minute intervals
* Subtract the baseline from each subsequent block
* Discard center, keep only lateral saccades

__Dependent measure__: saccadic latency

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (tDCS, post.1, post.2)
* DIRECTION (left vs. right)

```{r Kanai ANOVA, results='asis'}

latencyMedianBaselineLateral <- filter(latencyMedianBaseline, type == "lateral") # keep only lateral saccades

modelKanai <- ezANOVA(data = data.frame(latencyMedianBaselineLateral),
                        dv = .(latency), wid = .(subject), within = .(stimulation,leg,direction), type = 3)

# OR, without the EZ package:
# modelKanai=aov(latency~stimulation*leg*direction + Error(subject/(stimulation*leg*direction)),data=latencyMedianBaselineLateral)
# summary(modelKanai)

kable(modelKanai$ANOVA)
```

### Main effect of direction

```{r Main effect of direction}
latencyMedianBaselineLateral %>%
  group_by(subject,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(direction, latency)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.data = mean_cl_normal, size = 1) +
  geom_jitter(width = 0.25)
```

Right saccades become slower with respect to the baseline; left saccades do not. However, the effect is tiny (1-2 ms) and there is no interaction with STIMULATION.

## ANOVA without subtracting baseline, for lateral saccades - saccade latency

Kanai et al. analyzed the baseline-subtracted data; now repeat the same ANOVA with the baseline block still present.

__Data__: 

* Outliers removed
* Collapsed into 15-minute intervals
* Discard center, keep only lateral saccades

__Dependent measure__: saccadic latency

__Factors__:

* STIMULATION (anodal vs. cathodal)
* LEG (tDCS, post.1, post.2)
* DIRECTION (left vs. right)

```{r, Lateral saccade ANOVA, results='asis'}

# keep only lateral saccades
latencyMedianLateral <- latencyMedianLegExcl %>%
  filter(type == "lateral") %>%
  select(-type)

modelLateral <- ezANOVA(data = data.frame(latencyMedianLateral),
                        dv = .(latency), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelLateral$ANOVA)

```

### Leg by direction interaction

```{r Interaction leg by direction}
latencyMedianLateral %>%
  group_by(subject,leg,direction) %>%
  summarise(latency = mean(latency)) %>%
  ggplot(aes(leg, latency, shape = direction)) +
  stat_summary(fun.y = mean, geom = "point") +
  stat_summary(fun.y = mean, geom = "line", aes(group = direction, linetype = direction))
```

Pretty erratic pattern, and no interaction with STIMULATION either.

## ANOVA without subtracting baseline, for center saccades - saccade latency

Same as previous, but now for center saccades.

```{r, Center saccade ANOVA, results='asis'}
latencyMedianCenter <- latencyMedianLegExcl %>%
  filter(type == "center") %>%
  select(-type)

modelCenter <- ezANOVA(data = data.frame(latencyMedianCenter),
                        dv = .(latency), wid = .(subject), within = .(stimulation, leg, direction), type = 3)
kable(modelCenter$ANOVA)
```

## Bayesian linear mixed effects matching Kanai - saccade latency

### Test against the null model

```{r Compute Bayes Factors cf. null model}
bfKanaiNull = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(latencyMedianBaselineLateral), whichModels="withmain", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiNull = sort(bfKanaiNull, decreasing = TRUE) # sort such that winning model is at the top
```

First we compare all models to the most simple (null) model, which is the intercept only + random effect model: `latency ~ subject`. This does not test for effects of SUBJECT but models it as a nuisance factor (`whichRandom = "subject"`). In addition, to decrease the model space, we do not consider models that have an interaction without the corresponding main effects (`whichModels = "withmain"`).

```{r Extract Bayes Factors withMain, results='asis'}
kable(select(extractBF(bfKanaiNull), bf)) # show only the Bayes factors in a table
```

The winning model is the one with all main effects, with a Bayes factor of `r round(extractBF(bfKanaiNull[1], onlybf = TRUE), digits = 1)`. We can compute the evidence for a particular effect by comparing this winning model with the best-fitting model that does _not_ contain the effect. We can compute the evidence for _absence_ of a particular effect by comparing the winning model with the best-fitting model that _does_ contain the effect.

* STIMULATION. This effect can be quantified by comparing the Bayes factors of the first and the 3rd model : `r round(extractBF(bfKanaiNull[1] / bfKanaiNull[3], onlybf = TRUE), digits = 1)`. This constitues __moderate evidence for the presence of a stimulation effect__.
* DIRECTION. This effect can be quantified by comparing the first and the 2nd model : `r round(extractBF(bfKanaiNull[1] / bfKanaiNull[2], onlybf = TRUE), digits = 1)`. This constitues __anecdotal evidence for the presence of a direction effect__.

* Interaction of STIMULATION and DIRECTION. This term is not in the winning model, and first shows up in the fourth model. The Bayes factor for the comparison of both models is `r round(extractBF(bfKanaiNull[1] / bfKanaiNull[4], onlybf = TRUE), digits = 1)`. This constitues __moderate evidence for the absence of an interaction between stimulation and direction__.
* Interaction of STIMULATION, and LEG. Bayes factor: `r round(extractBF(bfKanaiNull[1] / bfKanaiNull[8], onlybf = TRUE), digits = 1)`. This constitutes __moderate evidence for the absence of an interaction between stimulation and leg__.
* Three-way interaction. Bayes factor: `r round(extractBF(bfKanaiNull[1] / bfKanaiNull[18], onlybf = TRUE), digits = 1)`. This constitutes __strong evidence for the absence of an interaction between stimulation, leg and direction__.

### Test against the full model

Another option for quantifying evidence for a particular effect is to compare the full model to a model where that effect is omitted (`whichModels = top")`. The full model is `stimulation + direction + stimulation:direction + leg + stimulation:leg + direction:leg + stimulation:direction:leg + subject`.

```{r Compute Bayes Factors cf. full model}
bfKanaiFull = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(latencyMedianBaselineLateral), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfKanaiFull
```

Removing the DIRECTION effect from the model yields a lower Bayes Factor, so including this effect improved the model. This thus constitues (some) evidence for the alternative: ` 1 \ ` `r round(extractBF(bfKanaiFull[6], onlybf = TRUE), digits = 3)` ` = ` `r round(extractBF(1/bfKanaiFull[6], onlybf = TRUE), digits = 1)`. The evidence for a stimulation effect is also about the same: `r round(extractBF(1/bfKanaiFull[7], onlybf = TRUE), digits = 1)`.

On the contrary, removing the interactions actually improves the model, so there is moderate evidence for the absence of interaction effects.

All in all, for most effects, the result is qualitatively similar to the approach of testing against the null-model. Only the evidence for absence of the three-way interaction is much, much smaller here.

## Bayesian linear mixed effects with baseline - saccade latency

Repeat the analysis when the baseline is not subtracted, and also for center saccades.

### Lateral saccades

```{r Compute Bayes Factors lateral with-baseline model}

# keep only lateral saccades
latencyMedianLateral <- latencyMedianLegExcl %>%
  filter(type == "lateral") %>%
  select(-type)
  
bfLateral = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(latencyMedianLateral), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfLateral
```

When including the baseline, the evidence for null effects are stronger all around.

### Center saccades

```{r Compute Bayes Factors center with-baseline model}

# keep only center saccades
latencyMedianCenter <- latencyMedianLegExcl %>%
  filter(type == "center") %>%
  select(-type)
  
bfCenter = anovaBF(latency~stimulation*leg*direction+subject, data = data.frame(latencyMedianCenter), whichModels="top", whichRandom = "subject", progress = FALSE, iterations = 100000) # compute Bayes Factors
bfCenter
```

Now the model improves all the time, no matter which effect is omitted.
